
# TornadoStyleShieldedPool Solidity Contracts

This directory contains the Solidity smart contracts for the Tornado-style privacy-preserving deposit and withdrawal system.

## Contract Overview

### Core Contracts

#### 1. `TransferVerifier.sol`
- **Purpose**: ZK-SNARK verifier contract generated by snarkjs
- **Function**: Verifies zero-knowledge proofs for private transfers
- **Key Features**:
  - Groth16 proof verification
  - Field validation for public signals
  - Elliptic curve pairing checks

#### 2. `TornadoStyleShieldedPool.sol`
- **Purpose**: Main privacy pool contract for deposits and withdrawals (Tornado-style)
- **Key Features**:
  - Private deposits using commitments
  - Zero-knowledge withdrawals with nullifier protection
  - Efficient Merkle tree with Poseidon hash
  - Root history for replay protection
  - Relayer support and fee handling
  - Emergency controls and operator management
  - Compliance verification (optional)

#### 3. `Poseidon.sol`
- **Purpose**: Poseidon hash implementation for Merkle tree and commitments
- **Key Features**:
  - Efficient field hashing
  - Used for privacy-preserving commitments and tree operations

## Key Security Features

### Privacy Protection
- **Commitment Scheme**: Deposits create commitments that hide the depositor's identity
- **Nullifier System**: Prevents double-spending while maintaining privacy
- **Merkle Tree**: Enables proof of membership without revealing position
- **Zero-Knowledge Proofs**: Withdrawals require valid ZK proofs

### Access Controls
- **Operator Controls**: Pool operators can pause deposits/withdrawals
- **Emergency Mode**: Emergency fund recovery
- **Fee Management**: Configurable withdrawal fees with limits
- **Root History**: Prevents old root attacks by maintaining recent root history

### Validation Systems
- **Field Element Validation**: Ensures all values are within the valid field
- **Proof Verification**: All withdrawals must provide valid ZK proofs
- **Amount Limits**: Configurable minimum and maximum deposit amounts
- **Nullifier Tracking**: Prevents reuse of spent notes

## Usage Examples

### Deposit Flow
```solidity
// Generate a commitment (client-side in real implementation)
bytes32 commitment = generateCommitment(amount, secret, nullifier);

// Deposit into the pool
pool.deposit{value: amount}(commitment);
```

### Withdrawal Flow
```solidity
// Generate ZK proof (client-side)
uint[8] memory proof = generateProof(secret, nullifier, merkleProof);

// Withdraw with proof
pool.withdraw(
    proof,
    nullifierHash,
    recipient,
    amount,
    merkleRoot
);
```

## Configuration Parameters

### Pool Limits
- **Minimum Deposit**: 0.01 ETH (configurable)
- **Maximum Deposit**: 100 ETH (configurable)
- **Tree Depth**: 20 levels (2^20 = ~1M deposits)
- **Root History**: 30 recent roots stored

### Fees and Limits
- **Default Withdrawal Fee**: 0.001 ETH
- **Maximum Fee**: 0.01 ETH (1% cap)
- **Batch Limit**: 10 operations per transaction

## Security Considerations

### Client-Side Requirements
- **Never expose secrets**: All secret values must be generated and stored client-side
- **Proof generation**: ZK proofs must be generated using the client with the circuit
- **Commitment tracking**: Users must securely store their note commitments
- **Nullifier management**: Prevent accidental reuse of nullifiers

### Operator Responsibilities
- **Pool monitoring**: Monitor for suspicious activity
- **Emergency response**: Ability to pause operations if needed
- **Fee management**: Set reasonable withdrawal fees
- **Root maintenance**: Ensure tree state integrity

### Known Limitations
- **Trusted Setup**: Requires trusted ceremony for proving keys
- **Gas Costs**: ZK proof verification is gas-intensive
- **Complexity**: Client-side proof generation requires specialized libraries
- **Anonymity Set**: Privacy depends on pool usage and mixing

## Integration with ZK Circuit

This contract system is designed to work with the `transfer.circom` circuit:

### Public Signals (Circuit ↔ Contract)
1. **nullifierHash**: Prevents double-spending
2. **recipient**: Withdrawal destination address
3. **amount**: Withdrawal amount
4. **merkleRoot**: Tree root for membership proof

### Private Signals (Circuit Only)
1. **secret**: Random value for commitment
2. **nullifier**: Unique nullifier value
3. **pathElements**: Merkle proof path
4. **pathIndices**: Merkle proof directions


## System Architecture

The following diagram illustrates the architecture of the Tornado-style privacy pool system:

```
┌─────────────────────────────┐    ┌─────────────────────────────┐    ┌───────────────────────┐
│   TransferVerifier.sol      │────│ TornadoStyleShieldedPool.sol│────│   Poseidon.sol        │
└─────────────────────────────┘    └─────────────────────────────┘    └───────────────────────┘
         │                                 │                              │
         │                        ┌─────────────────────┐                │
         └────────────────────────│   ZK Circuits       │────────────────┘
                                  └─────────────────────┘
```

**Components:**
- `TornadoStyleShieldedPool.sol`: Main privacy pool contract, manages deposits, withdrawals, Merkle tree, and relayer logic.
- `TransferVerifier.sol`: Verifies zero-knowledge proofs for withdrawals.
- `Poseidon.sol`: Provides Poseidon hash for Merkle tree and commitments.
- ZK Circuits (e.g., `transfer.circom`): Generates proofs for private transactions.

This modular architecture ensures privacy, security, and extensibility for shielded pool operations.



```
./scripts/build-circuits.sh arbitrumSepoliaUsdt
./scripts/build-circuits.sh arbitrumSepoliaEth